```{r setup,include=FALSE}
library(ggplot2)

theme_set(theme_minimal(base_size=12))
theme_update(legend.position="bottom")

if (require(viridis,quietly=TRUE)) {
  scale_colour_discrete <- function(...) {
    require(viridis,quietly=TRUE)
    scale_color_viridis(discrete=TRUE,end=0.85,option='D',...)
  }
  scale_fill_discrete <- function(...) {
    require(viridis,quietly=TRUE)
    scale_fill_viridis(discrete=TRUE,end=0.85,option='D',...)
  }
  # wait, can I also default for continuous cases?
  scale_colour_continuous <- function(...) {
    require(viridis,quietly=TRUE)
    scale_color_viridis(discrete=FALSE,end=0.85,option='D',...)
  }
  scale_fill_continuous <- function(...) {
    require(viridis,quietly=TRUE)
    scale_fill_viridis(discrete=FALSE,end=0.85,option='D',...)
  }
}

# set the knitr options ... for everyone!
# if you unset this, then vignette build bonks. oh, joy.
#opts_knit$set(progress=TRUE)
opts_knit$set(eval.after='fig.cap')
# for a package vignette, you do want to echo.
# opts_chunk$set(echo=FALSE,warning=FALSE,message=FALSE)
opts_chunk$set(warning=FALSE,message=FALSE)
#opts_chunk$set(results="asis")
opts_chunk$set(cache=TRUE,cache.path="cache/")

#opts_chunk$set(fig.path="github_extra/figure/",dev=c("pdf","cairo_ps"))
#opts_chunk$set(fig.path="github_extra/figure/",dev=c("png","pdf"))
opts_chunk$set(fig.path="tools/figure/",dev=c("png"))
opts_chunk$set(fig.width=7,fig.height=6,dpi=100,out.width='700px',out.height='600px')

# doing this means that png files are made of figures;
# the savings is small, and it looks like shit:
#opts_chunk$set(fig.path="figure/",dev=c("png","pdf","cairo_ps"))
#opts_chunk$set(fig.width=4,fig.height=4)
# for figures? this is sweave-specific?
#opts_knit$set(eps=TRUE)

# this would be for figures:
#opts_chunk$set(out.width='.8\\textwidth')
# for text wrapping:
options(width=64,digits=2)
opts_chunk$set(size="small")
opts_chunk$set(tidy=TRUE,tidy.opts=list(width.cutoff=50,keep.blank.line=TRUE))

#rnmf.meta <- packageDescription('rnmf')
```

# rnmf

```{r ignore,include=FALSE,eval=FALSE}
# [![Build Status](https://github.com/shabbychef/rnmf/workflows/R-CMD-check/badge.svg)](https://github.com/shabbychef/rnmf/actions)
# [![codecov.io](http://codecov.io/github/shabbychef/rnmf/coverage.svg?branch=master)](http://codecov.io/github/shabbychef/rnmf?branch=master)
# [![CRAN](http://www.r-pkg.org/badges/version/rnmf)](https://cran.r-project.org/package=rnmf)
# [![Downloads](http://cranlogs.r-pkg.org/badges/rnmf?color=green)](http://www.r-pkg.org/pkg/rnmf)
# [![Total](http://cranlogs.r-pkg.org/badges/grand-total/rnmf?color=green)](http://www.r-pkg.org/pkg/rnmf)
```

Implements regularized non-negative matrix factorization by a method similar to 
Lee & Seung, "Algorithms for Non-negative Matrix Factorization," 2001.

-- Steven E. Pav, shabbychef@gmail.com

## Installation

This package may be installed from CRAN; the latest version may be
found on [github](https://www.github.com/shabbychef/rnmf "rnmf")
via devtools, or installed via [drat](https://github.com/eddelbuettel/drat "drat"):

```{r install,eval=FALSE,echo=TRUE}
# CRAN
install.packages(c('rnmf'))
# devtools
if (require(devtools)) {
	# latest greatest
	install_github('shabbychef/rnmf')
}
# via drat:
if (require(drat)) {
	drat:::add('shabbychef')
	# not yet:
	# install.packages('rnmf')
}
```

# Basic Usage

We demonstrate the usage of the multiplicative and additive updates in
factoring a small matrix which we constructed to be the product of two
reduced rank non-negative matrices.

```{r basic_simulations,cache=TRUE,eval=TRUE,echo=TRUE,dpi=200,out.width='600px',out.height='500px'}
library(dplyr)
library(rnmf)
library(ggplot2)

frobenius_norm_err <- function(Y, L, R) {
	sqrt(sum(abs(Y - L %*% R)^2))
}
runifmat <- function(nr,nc,...) {
	matrix(pmax(0,runif(nr*nc,...)),nrow=nr)
}
test_a_bunch <- function(Y_t, L_0, R_0, niter=1e4L) {
	history <<- rep(NA_real_, niter)
	on_iteration_end <- function(iteration, Y, L, R, ...) {
		history[iteration] <<- frobenius_norm_err(Y,L,R)
	}
	wuz <- aurnmf(Y_t, L_0, R_0, max_iterations=length(history), on_iteration_end=on_iteration_end)
	df1 <- tibble(x=seq_along(history),y=history) %>% mutate(method='additive, optimal step')

	history <<- rep(NA_real_, niter)
	wuz <- murnmf(Y_t, L_0, R_0, max_iterations=length(history), on_iteration_end=on_iteration_end)
	df2 <- tibble(x=seq_along(history),y=history) %>% mutate(method='multiplicative')

	retv <- bind_rows(df1,df2) %>%
		mutate(nr=nrow(Y_t),
					 nc=ncol(Y_t),
					 nd=ncol(L_0),
					 max_iter=niter)
	return(retv)
}

nr <- 30
nc <- 8
nd <- 3
set.seed(1234)
L_t <- runifmat(nr,nd)
R_t <- runifmat(nd,nc)
Y_t <- L_t %*% R_t

L_0 <- runifmat(nrow(Y_t),nd+1)
R_0 <- runifmat(ncol(L_0),ncol(Y_t))

test_a_bunch(Y_t, L_0, R_0, niter=1e4L) %>%
	ggplot(aes(x,y,color=method)) + 
	geom_line() + 
	scale_x_log10(labels=scales::comma) + scale_y_log10() +
	labs(x='Step',y=expression(L[2]~~Error),
			 title='Frobenius Norm of Error vs Step',color='Method',
			 caption=paste0('Factoring ',nr,' x ',nc,' matrix down to ',nd,' dimensions.'))


```


## See also

* The original paper, by Lee, Daniel D. and Seung, H. Sebastian.
	[Algorithms for Non-negative Matrix Factorization](http://papers.nips.cc/paper/1861-algorithms-for-non-negative-matrix-factorization.pdf), 2001.
* Pav, Steven E. [System and method for unmixing spectroscopic observations with nonnegative matrix factorization](https://patentscope.wipo.int/search/en/detail.jsf?docId=US42758160), 2012.

